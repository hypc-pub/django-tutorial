{"./":{"url":"./","title":"Django简介","keywords":"","body":"Django Tutorial Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式，即模型M，视图V和控制器C。 Django的主要目的是简便、快速的开发数据库驱动的网站。 它强调代码复用，多个组件可以很方便的以“插件”形式服务于整个框架，Django有许多功能强大的第三方插件， 你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。 它还强调快速开发和DRY(Do Not Repeat Yourself)原则。 Django基于MVC的设计十分优美： 对象关系映射 (ORM,object-relational mapping)：以Python类形式定义你的数据模型， ORM将模型与关系数据库连接起来，你将得到一个非常容易使用的数据库API，同时你也可以在Django中使用原始的SQL语句。 URL 分派：使用正则表达式匹配URL，你可以设计任意的URL，没有框架的特定限定。像你喜欢的一样灵活。 模版系统：使用Django强大而可扩展的模板语言，可以分隔设计、内容和Python代码。并且具有可继承性。 表单处理：你可以方便的生成各种表单模型，实现表单的有效性检验。可以方便的从你定义的模型实例生成相应的表单。 Cache系统：可以挂在内存缓冲或其它的框架实现超级缓冲 －－ 实现你所需要的粒度。 会话(session)，用户登录与权限检查，快速开发用户会话功能。 国际化：内置国际化系统，方便开发出多种语言的网站。 自动化的管理界面：不需要你花大量的工作来创建人员管理和更新内容。Django自带一个ADMIN site,类似于内容管理系统。 "},"base/install.html":{"url":"base/install.html","title":"Django安装","keywords":"","body":"Django安装 安装Python Linux系统下安装 linux系统已经自带Python，可以直接使用。 Windows系统下安装 直接去 https://www.python.org/downloads/ 下载一个最新稳定版，安装即可。 安装Django 直接使用pip install Django命令安装， Windows系统下可以使用python -m pip install Django命令安装。 "},"base/section1.html":{"url":"base/section1.html","title":"Create a project","keywords":"","body":"编写第一个Django应用 -- Create a project 创建一个项目 直接使用下面命令创建一个项目： django-admin startproject mysite 命令执行成功之后会在当前目录下创建一个mysite的项目，项目结构如下： mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 外层的mysite/目录是项目的根目录； manage.py文件可以认为是django项目入口， 可以通过执行python manage.py 命令与django项目进行各种交互； 内层的mysite/目录是一个真实的Python package，它用来放置项目； mysite/__init__.py一个空白的文件，它用来告诉Python当前目录是一个Python package； mysite/settings.py，项目的配置文件，参考Django settings； mysite/urls.py，负责把URL模式映射到应用程序，参考URL dispatcher； mysite/wsgi.py，兼容WSGI的Web服务器的入口文件，参考How to deploy with WSGI。 运行Django服务 在项目根目录下运行下面任一命令启动服务： # 默认启动绑定127.0.0.1 python manage.py runserver # 绑定到127.0.0.1:8080 python manage.py runserver 8080 # 绑定到0.0.0.0:8080 python manage.py runserver 0.0.0.0:8080 创建第一个App -- Polls 使用下面命令创建一个App： python manage.py startapp polls 命令执行成功后，会在项目根目录下新建一个polls目录，目录结构如下： polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 编写第一个view 打开文件polls/view.py，并输入以下内容： from django.http import HttpResponse def index(request): return HttpResponse(\"Hello, world. You're at the polls index.\") 新建文件polls/urls.py，并输入以下内容： from django.urls import path from . import views urlpatterns = [ path('', views.index, name='index'), ] 然后打开mysite/urls.py文件，并输入下面内容： from django.contrib import admin from django.urls import include, path urlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls), ] 所有文件编写完成之后，启动服务： python manage.py runserver 最后你可以通过打开 http://localhost:8000/polls/ 来访问服务。 path函数可以传入4个参数，两个必选参数route、view，两个可选参数kwargs、name。 path参数：route route是一个包含URL模式的字符串。处理请求时，Django从urlpatterns中的第一个模式开始， 沿着列表向下移动，将请求的URL与每个模式进行比较，直到找到匹配的模式。 path参数：view 当Django找到匹配的模式时，它调用指定的视图函数，其中HttpRequest对象作为第一个参数， 并且路由中的任何“捕获”值作为关键字参数。 path参数：kwargs 任意关键字参数可以在字典中传递到目标视图。 path参数：name 命名您的URL可让您从Django的其他地方明确地引用它，尤其是在模板中。 此强大功能允许您在仅触摸单个文件的同时对项目的URL模式进行全局更改。 "},"base/section2.html":{"url":"base/section2.html","title":"Models & Admin site","keywords":"","body":"编写第一个Django应用 -- Models & Admin site 数据库设置 打开mysite/settings.py文件，这里面都是一些Django配置。 默认情况下，Django使用SQLite数据库，当然你也可以替换成其他数据库。 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } ENGINE: 可以是django.db.backends.sqlite3、django.db.backends.postgresql、 django.db.backends.mysql、django.db.backends.oracle，也可以是其他可能的值； NAME: 数据库名称。如果使用SQLite，那它是数据库文件。 如果使用SQLite数据库之外的其他数据库，那么还需要一些其他配置，如USER、PASSWORD、HOST。 具体参见DATABASES。 数据库设置完之后，需要将TIME_ZONE设置为你所在的时区。 另外还需要注意INSTALLED_APPS这个配置，它包含在这个项目中用到的App，里面有一些默认的设置： django.contrib.admin: Admin site； django.contrib.auth: 一个授权系统； django.contrib.contenttypes: content type框架； django.contrib.sessions: session框架； django.contrib.messages: 消息框架； django.contrib.staticfiles: 管理静态文件的框架。 其中一些App用到了数据库表，所以在使用之前需要在数据库中创建这些表，使用下面命令： python manage.py migrate 创建models 现在开始定义models，它本质上可以认为是数据库表结构。 打开polls/models.py文件，输入以下内容： from django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 这里定义了两个model：Question、Choice，他们都是django.db.models.Model子类。 每个字段都是Field类的实例。例如CharField、DateTimeField等。 激活models 在项目需要添加polls app，需要在INSTALLED_APPS中添加polls.apps.PollsConfig类， 打开mysite/settings.py文件，并按如下配置： INSTALLED_APPS = [ 'polls.apps.PollsConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] 设置INSTALLED_APPS后执行下面命令： $ python manage.py makemigrations polls Migrations for 'polls': polls/migrations/0001_initial.py: - Create model Choice - Create model Question - Add field question to choice 通过运行makemigrations，告诉Django已对model进行了一些更改（在这种情况下是创建了新模型），并且将更改存储为迁移文件。 可以使用migrate命令自动管理数据库，也可以使用sqlmigrate命令导出SQL语句。 执行migrate命令，效果如下： $ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, polls, sessions Running migrations: Rendering model states... DONE Applying polls.0001_initial... OK 使用database API 可以使用django交互式命令行来使用database API，执行命令如下： python manage.py shell 现在，可以使用database API： >>> from polls.models import Choice, Question # 现在还没有任何Question >>> Question.objects.all() # 创建一个Question并保存 >>> from django.utils import timezone >>> q = Question(question_text=\"What's new?\", pub_date=timezone.now()) >>> q.save() >>> q.id 1 >>> q.question_text \"What's new?\" >>> q.pub_date datetime.datetime(2018, 10, 21, 14, 14, 51, 932745, tzinfo=) # 修改q.question_text值并保存 >>> q.question_text = \"What's up?\" >>> q.save() # 查看所有的Question >>> Question.objects.all() ]> 等等，显示效果并不是很友好， 打开polls/models.py文件，并为Question和Choice添加__str__函数： from django.db import models class Question(models.Model): # ... def __str__(self): return self.question_text class Choice(models.Model): # ... def __str__(self): return self.choice_text 也可以为model添加自定义函数： from datetime import timedelta from django.db import models from django.utils import timezone class Question(models.Model): # ... def was_published_recently(self): return self.pub_date >= timezone.now() - timedelta(days=1) 然后再次执行命令python manage.py shell打开django shell： >>> from polls.models import Choice, Question # Make sure our __str__() addition worked. >>> Question.objects.all() ]> # Django provides a rich database lookup API that's entirely driven by # keyword arguments. >>> Question.objects.filter(id=1) ]> >>> Question.objects.filter(question_text__startswith='What') ]> # Get the question that was published this year. >>> from django.utils import timezone >>> current_year = timezone.now().year >>> Question.objects.get(pub_date__year=current_year) # Request an ID that doesn't exist, this will raise an exception. >>> Question.objects.get(id=2) Traceback (most recent call last): ... DoesNotExist: Question matching query does not exist. # Lookup by a primary key is the most common case, so Django provides a # shortcut for primary-key exact lookups. # The following is identical to Question.objects.get(id=1). >>> Question.objects.get(pk=1) # Make sure our custom method worked. >>> q = Question.objects.get(pk=1) >>> q.was_published_recently() True # Give the Question a couple of Choices. The create call constructs a new # Choice object, does the INSERT statement, adds the choice to the set # of available choices and returns the new Choice object. Django creates # a set to hold the \"other side\" of a ForeignKey relation # (e.g. a question's choice) which can be accessed via the API. >>> q = Question.objects.get(pk=1) # Display any choices from the related object set -- none so far. >>> q.choice_set.all() # Create three choices. >>> q.choice_set.create(choice_text='Not much', votes=0) >>> q.choice_set.create(choice_text='The sky', votes=0) >>> c = q.choice_set.create(choice_text='Just hacking again', votes=0) # Choice objects have API access to their related Question objects. >>> c.question # And vice versa: Question objects get access to Choice objects. >>> q.choice_set.all() , , ]> >>> q.choice_set.count() 3 # The API automatically follows relationships as far as you need. # Use double underscores to separate relationships. # This works as many levels deep as you want; there's no limit. # Find all Choices for any question whose pub_date is in this year # (reusing the 'current_year' variable we created above). >>> Choice.objects.filter(question__pub_date__year=current_year) , , ]> # Let's delete one of the choices. Use delete() for that. >>> c = q.choice_set.filter(choice_text__startswith='Just hacking') >>> c.delete() Django Admin 创建管理员帐号 首先创建管理员帐号： python manage.py createsuperuser 然后按照提示输入用户名、邮箱、密码。 启动服务并登录 执行命令： python manage.py runserver 然后打开浏览器访问网页 http://127.0.0.1:8000/admin/ ，输入上一步创建的帐号密码登录。 让polls在admin site中可见 登录之后，我们在admin site页面中并没有发现polls app。 修改polls/admin.py文件： from django.contrib import admin from .models import Question admin.site.register(Question) 这时候可以看到在admin site页面中看到polls app，并在下面看到Questi model。 "},"base/section3.html":{"url":"base/section3.html","title":"Views & Urls & Forms","keywords":"","body":"编写第一个Django应用 -- Views & Urls & Forms 编写更多的View 我们的View都是基于Base views而编写的。 打开polls/views.py文件，将文件内容修改如下： from django.http import HttpResponse from django.views import View class IndexView(View): def get(self, request): return HttpResponse(\"Hello, world. You're at the polls index.\") class DetailView(View): def get(self, request, question_id): return HttpResponse(\"You're looking at question %s.\" % question_id) class ResultsView(View): def get(self, request, question_id): response = \"You're looking at the results of question %s.\" return HttpResponse(response % question_id) class VoteView(View): def get(self, request, question_id): return HttpResponse(\"You're voting on question %s.\" % question_id) 然后修改polls/urls.py文件内容修改如下： from django.urls import path from .views import IndexView, DetailView, ResultsView, VoteView # ex: /polls/... urlpatterns = [ path('', IndexView.as_view(), name='index'), path('/', DetailView.as_view(), name='detail'), path('/results/', ResultsView.as_view(), name='results'), path('/vote/', VoteView.as_view(), name='vote'), ] 现在，可以启动服务，访问 http://127.0.0.1:8000/polls/1/ 查看效果。 让View做一些真实的事情 同样，打开polls/views.py文件，修改IndexView如下： from django.http import HttpResponse from django.views import View from .models import Question class IndexView(View): def get(self, request): latest_question_list = Question.objects.order_by('-pub_date')[:5] output = ', '.join([q.question_text for q in latest_question_list]) return HttpResponse(output) 启动服务，访问 http://127.0.0.1:8000/polls/ 查看效果。 使用Form 首先，新建文件polls/forms.py，创建一个Form类： from django import forms class QuestionIndexForm(forms.Form): question_text = forms.CharField(max_length=100, label='question_text') 然后修改polls/views.py文件的IndexView： from django.http import HttpResponse from django.views import View from .models import Question from .forms import QuestionIndexForm class IndexView(View): def get(self, request): form = QuestionIndexForm(request.GET) if not form.is_valid(): return HttpResponse('', status=422) data = form.cleaned_data latest_question_list = Question.objects.filter( question_text__contains=data['question_text']).order_by('-pub_date')[:5] output = ', '.join([q.question_text for q in latest_question_list]) return HttpResponse(output) 启动服务，访问 http://127.0.0.1:8000/polls/?question_text=What 查看效果。 "},"base/section4.html":{"url":"base/section4.html","title":"Testing","keywords":"","body":"编写第一个Django应用 -- Testing 第一个测试用例 打开文件polls/tests.py，编辑如下： import datetime from django.test import TestCase from django.utils import timezone from .models import Question class QuestionModelTests(TestCase): def test_was_published_recently_with_future_question(self): \"\"\" was_published_recently() returns False for questions whose pub_date is in the future. \"\"\" time = timezone.now() + datetime.timedelta(days=30) future_question = Question(pub_date=time) self.assertIs(future_question.was_published_recently(), False) 执行测试用例 使用下面命令运行测试用例： $ python manage.py test polls Creating test database for alias 'default'... System check identified no issues (0 silenced). F ====================================================================== FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests) ---------------------------------------------------------------------- Traceback (most recent call last): File \"/path/to/mysite/polls/tests.py\", line 16, in test_was_published_recently_with_future_question self.assertIs(future_question.was_published_recently(), False) AssertionError: True is not False ---------------------------------------------------------------------- Ran 1 test in 0.001s FAILED (failures=1) Destroying test database for alias 'default'... 执行完发现一个bug，打开文件polls/models.py修复这个bug： def was_published_recently(self): now = timezone.now() return now - datetime.timedelta(days=1) 再次执行测试用例： $ python manage.py test polls Creating test database for alias 'default'... System check identified no issues (0 silenced). . ---------------------------------------------------------------------- Ran 1 test in 0.001s OK Destroying test database for alias 'default'... 测试View Django提供Client用来测试View， from datetime import timedelta from django.test import TestCase from django.urls import reverse from django.utils import timezone def create_question(question_text, days): \"\"\" Create a question with the given `question_text` and published the given number of `days` offset to now (negative for questions published in the past, positive for questions that have yet to be published). \"\"\" time = timezone.now() + timedelta(days=days) return Question.objects.create(question_text=question_text, pub_date=time) class QuestionIndexViewTests(TestCase): def test_no_questions(self): \"\"\" If no questions exist, an appropriate message is displayed. \"\"\" # 这里也可以直接使用 self.client.get('polls/') 请求 response = self.client.get(reverse('polls:index')) self.assertEqual(response.status_code, 200) self.assertContains(response, \"No polls are available.\") self.assertQuerysetEqual(response.context['latest_question_list'], []) class QuestionDetailViewTests(TestCase): def test_future_question(self): \"\"\" The detail view of a question with a pub_date in the future returns a 404 not found. \"\"\" future_question = create_question(question_text='Future question.', days=5) url = reverse('polls:detail', args=(future_question.id,)) response = self.client.get(url) self.assertEqual(response.status_code, 404) "}}